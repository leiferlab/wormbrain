<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>wormbrain.match API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wormbrain.match</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import json
import wormbrain as wormb
import pkg_resources

filename_matches = &#34;matches.txt&#34;

def pairwise_distance(A,B,returnAll=False,squared=False,thresholdDz=0.0):
    &#39;&#39;&#39;
    Calculates the pairwise distance between points belonging to two sets of
    points.

    Parameters
    ----------
    A, B: np.array
        Sets of points between witch to calculate the distance. Indexes are
        [point_index, coordinate].
    returnAll: bool (optional)
        If True, the function returns both the distance and the vector 
        difference between the points in A and B. Default: False
    squared: bool (optional)
        If True, the square of the distances are returned, instead of the 
        distances. Default: False.
    thresholdDz: float (optional)
        If different from 0.0, the function sets to 0 all the z components
        of the vectorial difference between A and B that are smaller than this
        value.

    Returns
    -------
    D: np.array
        Matrix of the distances between each point in A and each point in B.
        Indexes are D[index_point_in_A, index_point_in_B].

    &#39;&#39;&#39;
    Dv = A[:,None]-B[None,:]

    if thresholdDz!=0.0:
        Dv[:,2,:] = 0.5*(np.sign(np.absolute(Dv[:,2,:])-thresholdDz)+1.0)*Dv[:,2,:]

    D = np.sum(np.power(Dv,2),axis=-1) # [a,b]
    if not squared:
        D = np.sqrt(D)

    if returnAll==True:
        return D, Dv
    else:
        return D


def match(A, B, method=&#39;nearest&#39;, registration=&#39;None&#39;, **kwargs):
    &#39;&#39;&#39;
    Computes the array giving the matching of points in B to points in A.

    Parameters
    ----------
    A, B: numpy array
        Sets of points to match. The function will calculate matches B-&gt;A.
        Indexes are [point_index, coordinate].
    method: string (optional)
        Method to match the neurons, after the registration between the two
        point sets. Default: &#34;nearest&#34;.
    registration: string (optional)
        Method to register the two point sets. Default: &#34;None&#34;.
    **kwargs:
        Other parameters to be passed to the registration function.

    Returns
    -------
    Match: np.array
        Indexes of points in A matching points in B.
        index_point_in_A = Match[index_point_in_B]

    &#39;&#39;&#39;

    if registration==&#39;centroid&#39;:
        A, B = wormb.reg.centroid(A,B,**kwargs)
    elif registration==&#39;displacement&#39;:
        A, B = wormb.reg.displacement(A,B,**kwargs)
    #elif registration==&#39;tps&#39;:
    #    A, B = wormb.reg.tps(A,B,**kwargs)
    elif registration==&#34;dsmm&#34;:
        try:
            fullpy = kwargs.pop(&#34;fullpy&#34;)
        except:
            fullpy = False
            
        if fullpy:
            B, A, p, Match = wormb.reg._dsmm_fullpy(B,A,returnAll=True,**kwargs)
        else:
            B, A, p, Match = wormb.reg.dsmmc(B,A,returnAll=True,**kwargs)
        return Match

    if method==&#39;nearest&#39;:
        Match = _match_nearest(A,B,**kwargs)
    return Match
    
def invert_matches(matches, N):
    &#39;&#39;&#39;Transforms the matches obtained matching points in B to points in A to
    the matches of points in A to points in B.
    
    Parameters
    ----------
    matches: numpy array of int
        The matches to be inverted. Obtained, e.g., with match(A,B,...).
        Contains the matches of points in B to points in A.
    N: int
        Number of elements in A.
        
    Returns
    -------
    inverted matches: numpy array of int
        The inverted matches, i.e. of points of A to points of B.
    &#39;&#39;&#39;
    
    inverted_matches = -1*np.ones(N, dtype=np.int)
    for i in np.arange(N):
        a = np.where(matches==i)[0]
        if len(a) &gt;0:
            inverted_matches[i] = a[0]
    
    return inverted_matches



def _match_nearest(A, B, **kwargs): #TODO implement it on multiple As
    &#39;&#39;&#39;Matches the neurons in A to the neurons in B based on a nearest-neighbor
    criterion.
    
    Parameters
    ----------
    A, B: numpy array
        The two point sets
        
    Returns
    -------
    Match: numpy array
        The array containing the matches.
    &#39;&#39;&#39;
    
    # Calculate pairwise distance between every pair of points in (B, A).T
    # Pass thresholdDz if it is in kwargs
    if &#34;thresholdDz&#34; in kwargs.keys():
        DD = pairwise_distance(A, B, thresholdDz=kwargs[&#34;thresholdDz&#34;])
    else:
        DD = pairwise_distance(A, B) # [a, b]
    # Find closest match for each point
    # For each B find closest A
    MatchAll = np.argsort(DD,axis=0) #0 or 1 depends on whether you want to match the A to the model or viceversa
    Match = MatchAll[0]
    distanceThreshold = kwargs[&#39;distanceThreshold&#39;]
    DDth = distanceThreshold*np.median(np.min(DD,axis=0))
    Match[np.where(np.min(DD,axis=0)&gt;DDth)] *= -10

    # Look for double matches
    unique, counts = np.unique(Match, return_counts=True)
    doubleMatch = np.where((counts!=1)*(unique&gt;=0))[0]

    # Keep only closest match
    for dm in doubleMatch:
        if unique[dm]&gt;0:
            # Bs matched to the same As
            pts = np.where(Match==unique[dm])[0]
            # Don&#39;t change the closest match
            pts = np.delete(pts, np.argmin(DD[unique[dm],pts]))
            # Assign the second closest match, if it is not already assigned. Should be recursive to get to the third closest and so on, with cutoff on the distance
            remainingPtsIndexes = np.argsort(DD[unique[dm],pts])
            for rpi in remainingPtsIndexes:
                pt = pts[rpi] # the next minimum
                jj = 1
                run = True
                while run:
                    if DD[MatchAll[jj,pt],pt] &lt; DDth:
                        if not np.isin(MatchAll[jj,pt],Match):
                            Match[pt] = MatchAll[jj,pt]
                            run = False
                    else:
                        Match[pt] *= -10
                        run = False
                    jj += 1

                    if jj &gt; MatchAll.shape[0] - 2: run = False

            #Match[pts] *= -10
                #Match[pt] = np.where( (not np.isin(MatchAll[1,pt],Match)) and (DD[MatchAll[1,pt],pt] &lt; DDth), MatchAll[1,pt], -10*Match[pt])

    return Match

def save_matches(MMatch, parameters, folder, filename=&#34;&#34;):
    &#39;&#39;&#39;Saves the matches to file, using the numpy savetxt function with the
    addition of a header containing json-serialized information about the 
    matching. The function will add the current version of the wormbrain module
    in the header.
    
    Parameters
    ----------
    MMatch: numpy array
        Array containing the matches
    parameters: dictionary
        Dictionary to be json-serialized and stored in the header.
    folder: string
        Destination folder.
    filename: string (optional)
        Destination filename. Default: &#34;&#34;, that is translated in the default
        filename for the module.
    &#39;&#39;&#39;
    
    if folder[-1]!=&#34;/&#34;: folder+=&#34;/&#34;
    if filename==&#34;&#34;: filename = filename_matches
    
    parameters[&#39;version&#39;] = pkg_resources.get_distribution(&#34;wormbrain&#34;).version

    headerInfo = json.dumps(parameters)
    np.savetxt(folder+filename,MMatch,header=headerInfo)

def load_matches(folder, filename=&#34;&#34;):
    &#39;&#39;&#39;Loads the matches from file.
    
    Parameters
    ----------
    folder: string
        Folder containing the file.
    filename: string (optional)
        Name of the file. Default: &#34;&#34;, that is translated to the default 
        filename for the module.
    
    Returns
    -------
    MMatch: numpy array
        Array containing the matches.
    parameters: dictionary
        Dictionary contained in the header, with the information about the 
        matching
    &#39;&#39;&#39;
    
    if folder[-1]!=&#34;/&#34;: folder+=&#34;/&#34;
    if filename==&#34;&#34;: filename = filename_matches
    
    f = open(folder+filename,&#34;r&#34;)
    l = f.readline()
    f.close()
    try:
        parameters = json.loads(l[2:])
    except:
        parameters = {}

    MMatch = np.loadtxt(folder+filename_matches)

    return MMatch, parameters
    
def load_match_parameters(folder, filename=&#34;&#34;):
    &#39;&#39;&#39;Loads the matching parameters from file, only using its header. This
    function does not load the matches themselves. Use load_matches() for that.
    
    Parameters
    ----------
    folder: string
        Folder containing the file.
    filename: string (optional)
        Name of the file. Default: &#34;&#34;, that is translated to the default 
        filename for the module.
    
    Returns
    -------
    parameters: dictionary
        Dictionary contained in the header, with the information about the 
        matching
    &#39;&#39;&#39;
    if folder[-1]!=&#34;/&#34;: folder+=&#34;/&#34;
    if filename==&#34;&#34;: filename = filename_matches
    
    f = open(folder+filename,&#34;r&#34;)
    l = f.readline()
    f.close()
    try:
        parameters = json.loads(l[2:])
    except:
        parameters = {}

    return parameters


def plot_matches(A, B, Match, mode=&#39;3d&#39;,plotNow=True,**kwargs):
    &#39;&#39;&#39;Plots the two point sets with lines representing the matches, in 2D or 
    3D. The function redirects the call to _plot_matches_3d() or _2d(). If 
    matplotlib has already a figure, the function uses the one after the one
    currently in use.
    
    Parameters
    ----------
    A, B: numpy arrays
        The two point sets.
    Match: numpy array
        The array containing the matches.
    mode: string (optional)
        Possible values: &#34;3d&#34; or &#34;2d&#34;. Default: &#34;3d&#34;.
    plotNow: boolean (optional)
        If True, the plot is displayed immediately. If False, figure and axis
        will be returned, to be displayed later in the script. Default: True.
    **kwargs: 
        Any other parameter to be passed to _plot_matches_3d or _2d.
        
    Returns
    -------
    fig: matplotlib figure 
        Returned if plotNow is False.
    ax: matplotlib axis
        Returned if plotNow is False.
    
    &#39;&#39;&#39;
    if mode==&#39;3d&#39;:
        fig, ax = _plot_matches_3d(A, B, Match, **kwargs)
    if mode==&#39;2d&#39;:
        fig, ax = _plot_matches_2d(A, B, Match, **kwargs)

    if plotNow==True:
        plt.show()
        return
    else:
        return fig, ax


def _plot_matches_3d(A, B, Match,**kwargs):
    &#39;&#39;&#39;Plot matches in a 3D plot. If matplotlib has already a figure, the 
    function uses the one after the one currently in use.
    
    Parameters
    ----------
    A, B: numpy arrays
        The arrays containing the point sets.
    Match: numpy array
        The matches.
    
    Returns
    -------
    fig: matplotlib figure 
    ax: matplotlib axis
    &#39;&#39;&#39;
    
    cfn = plt.gcf().number
    if len(plt.gcf().axes)!=0: cfn += 1

    showAll=True
    if &#39;showAll&#39; in kwargs: showAll=kwargs[&#39;showAll&#39;]

    fig = plt.figure(cfn)
    ax = fig.add_subplot(111,projection=&#39;3d&#39;)

    ax.scatter(A.T[0],A.T[1],A.T[2],&#39;o&#39;,c=&#39;green&#39;)
    ax.scatter(B.T[0],B.T[1],B.T[2],&#39;o&#39;,c=&#39;red&#39;,s=2)
    I = len(Match)
    for i in np.arange(I):
        j = Match[i]
        if j&gt;0:
            ax.plot((A[j,0],B[i,0]),(A[j,1],B[i,1]),(A[j,2],B[i,2]),&#39;k-&#39;)
        else:
            j = -j//10
            ax.scatter(B[i,0],B[i,1],B[i,2],&#39;*&#39;,c=&#39;blue&#39;)
            if showAll:
                ax.plot((A[j,0],B[i,0]),(A[j,1],B[i,1]),(A[j,2],B[i,2]),&#39;--&#39;,c=&#39;orange&#39;)

    return fig, ax


def _plot_matches_2d(A, B, Match, **kwargs):
    &#39;&#39;&#39;Plot matches in a 2D plot. If matplotlib has already a figure, the 
    function uses the one after the one currently in use.
    
    Parameters
    ----------
    A, B: numpy arrays
        The arrays containing the point sets.
    Match: numpy array
        The matches.
    
    Returns
    -------
    fig: matplotlib figure 
    ax: matplotlib axis
    &#39;&#39;&#39;
    
    cfn = plt.gcf().number
    if len(plt.gcf().axes)!=0: cfn += 1

    showAll=True
    if &#39;showAll&#39; in kwargs: showAll=kwargs[&#39;showAll&#39;]

    fig = plt.figure(cfn)
    ax = fig.add_subplot(111)
    p = 0 # x in plot
    q = 1 # y in plot
    r = 2

    ax.plot(A.T[p],A.T[q],&#39;og&#39;)#,markersize=3)
    ax.plot(B.T[p],B.T[q],&#39;or&#39;,markersize=2)

    I = len(Match)
    for i in np.arange(I):
        j = Match[i]
        if j&gt;0:
            ax.plot((A[j,p],B[i,p]),(A[j,q],B[i,q]),&#39;k-&#39;)
        else:
            j = -j//10
            ax.plot(B[i,p],B[i,q],&#39;*b&#39;)
            if showAll:
                ax.plot((A[j,p],B[i,p]),(A[j,q],B[i,q]),&#39;--&#39;,c=&#39;orange&#39;)

    return fig, ax</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wormbrain.match.invert_matches"><code class="name flex">
<span>def <span class="ident">invert_matches</span></span>(<span>matches, N)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the matches obtained matching points in B to points in A to
the matches of points in A to points in B.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matches</code></strong> :&ensp;<code>numpy array</code> of <code>int</code></dt>
<dd>The matches to be inverted. Obtained, e.g., with match(A,B,&hellip;).
Contains the matches of points in B to points in A.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of elements in A.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>inverted matches: numpy array</code> of <code>int</code></dt>
<dd>The inverted matches, i.e. of points of A to points of B.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert_matches(matches, N):
    &#39;&#39;&#39;Transforms the matches obtained matching points in B to points in A to
    the matches of points in A to points in B.
    
    Parameters
    ----------
    matches: numpy array of int
        The matches to be inverted. Obtained, e.g., with match(A,B,...).
        Contains the matches of points in B to points in A.
    N: int
        Number of elements in A.
        
    Returns
    -------
    inverted matches: numpy array of int
        The inverted matches, i.e. of points of A to points of B.
    &#39;&#39;&#39;
    
    inverted_matches = -1*np.ones(N, dtype=np.int)
    for i in np.arange(N):
        a = np.where(matches==i)[0]
        if len(a) &gt;0:
            inverted_matches[i] = a[0]
    
    return inverted_matches</code></pre>
</details>
</dd>
<dt id="wormbrain.match.load_match_parameters"><code class="name flex">
<span>def <span class="ident">load_match_parameters</span></span>(<span>folder, filename='')</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the matching parameters from file, only using its header. This
function does not load the matches themselves. Use load_matches() for that.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>string</code></dt>
<dd>Folder containing the file.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>Name of the file. Default: "", that is translated to the default
filename for the module.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Dictionary contained in the header, with the information about the
matching</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_match_parameters(folder, filename=&#34;&#34;):
    &#39;&#39;&#39;Loads the matching parameters from file, only using its header. This
    function does not load the matches themselves. Use load_matches() for that.
    
    Parameters
    ----------
    folder: string
        Folder containing the file.
    filename: string (optional)
        Name of the file. Default: &#34;&#34;, that is translated to the default 
        filename for the module.
    
    Returns
    -------
    parameters: dictionary
        Dictionary contained in the header, with the information about the 
        matching
    &#39;&#39;&#39;
    if folder[-1]!=&#34;/&#34;: folder+=&#34;/&#34;
    if filename==&#34;&#34;: filename = filename_matches
    
    f = open(folder+filename,&#34;r&#34;)
    l = f.readline()
    f.close()
    try:
        parameters = json.loads(l[2:])
    except:
        parameters = {}

    return parameters</code></pre>
</details>
</dd>
<dt id="wormbrain.match.load_matches"><code class="name flex">
<span>def <span class="ident">load_matches</span></span>(<span>folder, filename='')</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the matches from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>folder</code></strong> :&ensp;<code>string</code></dt>
<dd>Folder containing the file.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>Name of the file. Default: "", that is translated to the default
filename for the module.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>MMatch</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Array containing the matches.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Dictionary contained in the header, with the information about the
matching</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_matches(folder, filename=&#34;&#34;):
    &#39;&#39;&#39;Loads the matches from file.
    
    Parameters
    ----------
    folder: string
        Folder containing the file.
    filename: string (optional)
        Name of the file. Default: &#34;&#34;, that is translated to the default 
        filename for the module.
    
    Returns
    -------
    MMatch: numpy array
        Array containing the matches.
    parameters: dictionary
        Dictionary contained in the header, with the information about the 
        matching
    &#39;&#39;&#39;
    
    if folder[-1]!=&#34;/&#34;: folder+=&#34;/&#34;
    if filename==&#34;&#34;: filename = filename_matches
    
    f = open(folder+filename,&#34;r&#34;)
    l = f.readline()
    f.close()
    try:
        parameters = json.loads(l[2:])
    except:
        parameters = {}

    MMatch = np.loadtxt(folder+filename_matches)

    return MMatch, parameters</code></pre>
</details>
</dd>
<dt id="wormbrain.match.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>A, B, method='nearest', registration='None', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the array giving the matching of points in B to points in A.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong>, <strong><code>B</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Sets of points to match. The function will calculate matches B-&gt;A.
Indexes are [point_index, coordinate].</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>Method to match the neurons, after the registration between the two
point sets. Default: "nearest".</dd>
<dt><strong><code>registration</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>Method to register the two point sets. Default: "None".</dd>
</dl>
<p>**kwargs:
Other parameters to be passed to the registration function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Match</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Indexes of points in A matching points in B.
index_point_in_A = Match[index_point_in_B]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match(A, B, method=&#39;nearest&#39;, registration=&#39;None&#39;, **kwargs):
    &#39;&#39;&#39;
    Computes the array giving the matching of points in B to points in A.

    Parameters
    ----------
    A, B: numpy array
        Sets of points to match. The function will calculate matches B-&gt;A.
        Indexes are [point_index, coordinate].
    method: string (optional)
        Method to match the neurons, after the registration between the two
        point sets. Default: &#34;nearest&#34;.
    registration: string (optional)
        Method to register the two point sets. Default: &#34;None&#34;.
    **kwargs:
        Other parameters to be passed to the registration function.

    Returns
    -------
    Match: np.array
        Indexes of points in A matching points in B.
        index_point_in_A = Match[index_point_in_B]

    &#39;&#39;&#39;

    if registration==&#39;centroid&#39;:
        A, B = wormb.reg.centroid(A,B,**kwargs)
    elif registration==&#39;displacement&#39;:
        A, B = wormb.reg.displacement(A,B,**kwargs)
    #elif registration==&#39;tps&#39;:
    #    A, B = wormb.reg.tps(A,B,**kwargs)
    elif registration==&#34;dsmm&#34;:
        try:
            fullpy = kwargs.pop(&#34;fullpy&#34;)
        except:
            fullpy = False
            
        if fullpy:
            B, A, p, Match = wormb.reg._dsmm_fullpy(B,A,returnAll=True,**kwargs)
        else:
            B, A, p, Match = wormb.reg.dsmmc(B,A,returnAll=True,**kwargs)
        return Match

    if method==&#39;nearest&#39;:
        Match = _match_nearest(A,B,**kwargs)
    return Match</code></pre>
</details>
</dd>
<dt id="wormbrain.match.pairwise_distance"><code class="name flex">
<span>def <span class="ident">pairwise_distance</span></span>(<span>A, B, returnAll=False, squared=False, thresholdDz=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the pairwise distance between points belonging to two sets of
points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong>, <strong><code>B</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Sets of points between witch to calculate the distance. Indexes are
[point_index, coordinate].</dd>
<dt><strong><code>returnAll</code></strong> :&ensp;<code>bool (optional)</code></dt>
<dd>If True, the function returns both the distance and the vector
difference between the points in A and B. Default: False</dd>
<dt><strong><code>squared</code></strong> :&ensp;<code>bool (optional)</code></dt>
<dd>If True, the square of the distances are returned, instead of the
distances. Default: False.</dd>
<dt><strong><code>thresholdDz</code></strong> :&ensp;<code>float (optional)</code></dt>
<dd>If different from 0.0, the function sets to 0 all the z components
of the vectorial difference between A and B that are smaller than this
value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>D</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Matrix of the distances between each point in A and each point in B.
Indexes are D[index_point_in_A, index_point_in_B].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pairwise_distance(A,B,returnAll=False,squared=False,thresholdDz=0.0):
    &#39;&#39;&#39;
    Calculates the pairwise distance between points belonging to two sets of
    points.

    Parameters
    ----------
    A, B: np.array
        Sets of points between witch to calculate the distance. Indexes are
        [point_index, coordinate].
    returnAll: bool (optional)
        If True, the function returns both the distance and the vector 
        difference between the points in A and B. Default: False
    squared: bool (optional)
        If True, the square of the distances are returned, instead of the 
        distances. Default: False.
    thresholdDz: float (optional)
        If different from 0.0, the function sets to 0 all the z components
        of the vectorial difference between A and B that are smaller than this
        value.

    Returns
    -------
    D: np.array
        Matrix of the distances between each point in A and each point in B.
        Indexes are D[index_point_in_A, index_point_in_B].

    &#39;&#39;&#39;
    Dv = A[:,None]-B[None,:]

    if thresholdDz!=0.0:
        Dv[:,2,:] = 0.5*(np.sign(np.absolute(Dv[:,2,:])-thresholdDz)+1.0)*Dv[:,2,:]

    D = np.sum(np.power(Dv,2),axis=-1) # [a,b]
    if not squared:
        D = np.sqrt(D)

    if returnAll==True:
        return D, Dv
    else:
        return D</code></pre>
</details>
</dd>
<dt id="wormbrain.match.plot_matches"><code class="name flex">
<span>def <span class="ident">plot_matches</span></span>(<span>A, B, Match, mode='3d', plotNow=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the two point sets with lines representing the matches, in 2D or
3D. The function redirects the call to _plot_matches_3d() or _2d(). If
matplotlib has already a figure, the function uses the one after the one
currently in use.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong>, <strong><code>B</code></strong> :&ensp;<code>numpy arrays</code></dt>
<dd>The two point sets.</dd>
<dt><strong><code>Match</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>The array containing the matches.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>Possible values: "3d" or "2d". Default: "3d".</dd>
<dt><strong><code>plotNow</code></strong> :&ensp;<code>boolean (optional)</code></dt>
<dd>If True, the plot is displayed immediately. If False, figure and axis
will be returned, to be displayed later in the script. Default: True.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any other parameter to be passed to _plot_matches_3d or _2d.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>matplotlib figure </code></dt>
<dd>Returned if plotNow is False.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib axis</code></dt>
<dd>Returned if plotNow is False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_matches(A, B, Match, mode=&#39;3d&#39;,plotNow=True,**kwargs):
    &#39;&#39;&#39;Plots the two point sets with lines representing the matches, in 2D or 
    3D. The function redirects the call to _plot_matches_3d() or _2d(). If 
    matplotlib has already a figure, the function uses the one after the one
    currently in use.
    
    Parameters
    ----------
    A, B: numpy arrays
        The two point sets.
    Match: numpy array
        The array containing the matches.
    mode: string (optional)
        Possible values: &#34;3d&#34; or &#34;2d&#34;. Default: &#34;3d&#34;.
    plotNow: boolean (optional)
        If True, the plot is displayed immediately. If False, figure and axis
        will be returned, to be displayed later in the script. Default: True.
    **kwargs: 
        Any other parameter to be passed to _plot_matches_3d or _2d.
        
    Returns
    -------
    fig: matplotlib figure 
        Returned if plotNow is False.
    ax: matplotlib axis
        Returned if plotNow is False.
    
    &#39;&#39;&#39;
    if mode==&#39;3d&#39;:
        fig, ax = _plot_matches_3d(A, B, Match, **kwargs)
    if mode==&#39;2d&#39;:
        fig, ax = _plot_matches_2d(A, B, Match, **kwargs)

    if plotNow==True:
        plt.show()
        return
    else:
        return fig, ax</code></pre>
</details>
</dd>
<dt id="wormbrain.match.save_matches"><code class="name flex">
<span>def <span class="ident">save_matches</span></span>(<span>MMatch, parameters, folder, filename='')</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the matches to file, using the numpy savetxt function with the
addition of a header containing json-serialized information about the
matching. The function will add the current version of the wormbrain module
in the header.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>MMatch</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>Array containing the matches</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dictionary</code></dt>
<dd>Dictionary to be json-serialized and stored in the header.</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>string</code></dt>
<dd>Destination folder.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>string (optional)</code></dt>
<dd>Destination filename. Default: "", that is translated in the default
filename for the module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_matches(MMatch, parameters, folder, filename=&#34;&#34;):
    &#39;&#39;&#39;Saves the matches to file, using the numpy savetxt function with the
    addition of a header containing json-serialized information about the 
    matching. The function will add the current version of the wormbrain module
    in the header.
    
    Parameters
    ----------
    MMatch: numpy array
        Array containing the matches
    parameters: dictionary
        Dictionary to be json-serialized and stored in the header.
    folder: string
        Destination folder.
    filename: string (optional)
        Destination filename. Default: &#34;&#34;, that is translated in the default
        filename for the module.
    &#39;&#39;&#39;
    
    if folder[-1]!=&#34;/&#34;: folder+=&#34;/&#34;
    if filename==&#34;&#34;: filename = filename_matches
    
    parameters[&#39;version&#39;] = pkg_resources.get_distribution(&#34;wormbrain&#34;).version

    headerInfo = json.dumps(parameters)
    np.savetxt(folder+filename,MMatch,header=headerInfo)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wormbrain" href="index.html">wormbrain</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wormbrain.match.invert_matches" href="#wormbrain.match.invert_matches">invert_matches</a></code></li>
<li><code><a title="wormbrain.match.load_match_parameters" href="#wormbrain.match.load_match_parameters">load_match_parameters</a></code></li>
<li><code><a title="wormbrain.match.load_matches" href="#wormbrain.match.load_matches">load_matches</a></code></li>
<li><code><a title="wormbrain.match.match" href="#wormbrain.match.match">match</a></code></li>
<li><code><a title="wormbrain.match.pairwise_distance" href="#wormbrain.match.pairwise_distance">pairwise_distance</a></code></li>
<li><code><a title="wormbrain.match.plot_matches" href="#wormbrain.match.plot_matches">plot_matches</a></code></li>
<li><code><a title="wormbrain.match.save_matches" href="#wormbrain.match.save_matches">save_matches</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>